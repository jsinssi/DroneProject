import cv2
import numpy as np
from picamera2 import Picamera2


def find_colored_circle(hsv, color_name):
    """
    Find the centroid of a coloured landmark circle.
    Returns (cx, cy) or None.
    """

    if color_name == "red":
        # Red wraps around 0Â°, so we use two ranges
        lower1 = np.array([0, 120, 70])
        upper1 = np.array([10, 255, 255])
        lower2 = np.array([170, 120, 70])
        upper2 = np.array([180, 255, 255])
        mask1 = cv2.inRange(hsv, lower1, upper1)
        mask2 = cv2.inRange(hsv, lower2, upper2)
        mask = cv2.bitwise_or(mask1, mask2)

    elif color_name == "green":
        lower = np.array([35, 80, 80])
        upper = np.array([85, 255, 255])
        mask = cv2.inRange(hsv, lower, upper)

    elif color_name == "blue":
        # Tighter, saturated blue range to avoid table / paper
        lower = np.array([100, 100, 40])   # H, S, V
        upper = np.array([135, 255, 255])
        mask = cv2.inRange(hsv, lower, upper)

    else:
        return None

    # Clean the mask (remove specks)
    kernel = np.ones((5, 5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)

    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL,
                                   cv2.CHAIN_APPROX_SIMPLE)
    if not contours:
        return None

    # Filter contours by area and "circular-ish" shape
    MIN_AREA = 500     # tweak if needed
    MAX_AREA = 20000   # ignore huge things like the table
    best_cnt = None
    best_area = 0

    for cnt in contours:
        area = cv2.contourArea(cnt)
        if area < MIN_AREA or area > MAX_AREA:
            continue

        x, y, w, h = cv2.boundingRect(cnt)
        aspect = w / float(h)
        if not (0.7 <= aspect <= 1.3):
            continue  # not roughly square/circular

        if area > best_area:
            best_area = area
            best_cnt = cnt

    if best_cnt is None:
        return None

    M = cv2.moments(best_cnt)
    if M["m00"] == 0:
        return None

    cx = int(M["m10"] / M["m00"])
    cy = int(M["m01"] / M["m00"])
    return (cx, cy)


# -------------------------
# Camera setup
# -------------------------

picam2 = Picamera2()
config = picam2.create_preview_configuration(
    main={"size": (640, 480), "format": "RGB888"}
)
picam2.configure(config)
picam2.start()

print("Landmark detection running. Press 'q' to quit.")

try:
    while True:
        frame = picam2.capture_array()
        bgr = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
        hsv = cv2.cvtColor(bgr, cv2.COLOR_BGR2HSV)

        # Detect landmarks
        A = find_colored_circle(hsv, "red")
        B = find_colored_circle(hsv, "green")
        C = find_colored_circle(hsv, "blue")

        # Draw A (red)
        if A is not None:
            x, y = A
            cv2.circle(bgr, (x, y), 20, (0, 0, 255), 3)
            cv2.putText(bgr, "A", (x + 15, y),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)

        # Draw B (green)
        if B is not None:
            x, y = B
            cv2.circle(bgr, (x, y), 20, (0, 255, 0), 3)
            cv2.putText(bgr, "B", (x + 15, y),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)

        # Draw C (blue)
        if C is not None:
            x, y = C
            cv2.circle(bgr, (x, y), 20, (255, 0, 0), 3)
            cv2.putText(bgr, "C", (x + 15, y),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 0, 0), 2)

        cv2.imshow("Landmark Detection Test", bgr)

        if cv2.waitKey(1) & 0xFF == ord("q"):
            break

finally:
    picam2.stop()
    cv2.destroyAllWindows()
    print("Done.")
